// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: extract.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_extract_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_extract_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_extract_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_extract_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_extract_2eproto;
namespace kpex {
namespace tech {
class CapacitanceInfo;
struct CapacitanceInfoDefaultTypeInternal;
extern CapacitanceInfoDefaultTypeInternal _CapacitanceInfo_default_instance_;
class CapacitanceInfo_OverlapCapacitance;
struct CapacitanceInfo_OverlapCapacitanceDefaultTypeInternal;
extern CapacitanceInfo_OverlapCapacitanceDefaultTypeInternal _CapacitanceInfo_OverlapCapacitance_default_instance_;
class CapacitanceInfo_SideOverlapCapacitance;
struct CapacitanceInfo_SideOverlapCapacitanceDefaultTypeInternal;
extern CapacitanceInfo_SideOverlapCapacitanceDefaultTypeInternal _CapacitanceInfo_SideOverlapCapacitance_default_instance_;
class CapacitanceInfo_SidewallCapacitance;
struct CapacitanceInfo_SidewallCapacitanceDefaultTypeInternal;
extern CapacitanceInfo_SidewallCapacitanceDefaultTypeInternal _CapacitanceInfo_SidewallCapacitance_default_instance_;
class CapacitanceInfo_SubstrateCapacitance;
struct CapacitanceInfo_SubstrateCapacitanceDefaultTypeInternal;
extern CapacitanceInfo_SubstrateCapacitanceDefaultTypeInternal _CapacitanceInfo_SubstrateCapacitance_default_instance_;
class ExtractionInfo;
struct ExtractionInfoDefaultTypeInternal;
extern ExtractionInfoDefaultTypeInternal _ExtractionInfo_default_instance_;
class ResistanceInfo;
struct ResistanceInfoDefaultTypeInternal;
extern ResistanceInfoDefaultTypeInternal _ResistanceInfo_default_instance_;
class ResistanceInfo_LayerResistance;
struct ResistanceInfo_LayerResistanceDefaultTypeInternal;
extern ResistanceInfo_LayerResistanceDefaultTypeInternal _ResistanceInfo_LayerResistance_default_instance_;
class ResistanceInfo_ViaResistance;
struct ResistanceInfo_ViaResistanceDefaultTypeInternal;
extern ResistanceInfo_ViaResistanceDefaultTypeInternal _ResistanceInfo_ViaResistance_default_instance_;
class StyleVariant;
struct StyleVariantDefaultTypeInternal;
extern StyleVariantDefaultTypeInternal _StyleVariant_default_instance_;
}  // namespace tech
}  // namespace kpex
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kpex {
namespace tech {

// ===================================================================


// -------------------------------------------------------------------

class StyleVariant final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:kpex.tech.StyleVariant) */ {
 public:
  inline StyleVariant() : StyleVariant(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StyleVariant(
      ::google::protobuf::internal::ConstantInitialized);

  inline StyleVariant(const StyleVariant& from) : StyleVariant(nullptr, from) {}
  inline StyleVariant(StyleVariant&& from) noexcept
      : StyleVariant(nullptr, std::move(from)) {}
  inline StyleVariant& operator=(const StyleVariant& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleVariant& operator=(StyleVariant&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleVariant& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleVariant* internal_default_instance() {
    return reinterpret_cast<const StyleVariant*>(
        &_StyleVariant_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(StyleVariant& a, StyleVariant& b) { a.Swap(&b); }
  inline void Swap(StyleVariant* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleVariant* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleVariant* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<StyleVariant>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StyleVariant& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StyleVariant& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.StyleVariant"; }

 protected:
  explicit StyleVariant(::google::protobuf::Arena* arena);
  StyleVariant(::google::protobuf::Arena* arena, const StyleVariant& from);
  StyleVariant(::google::protobuf::Arena* arena, StyleVariant&& from) noexcept
      : StyleVariant(arena) {
    *this = ::std::move(from);
  }

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:kpex.tech.StyleVariant)
 private:
  class _Internal;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class ResistanceInfo_ViaResistance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.ResistanceInfo.ViaResistance) */ {
 public:
  inline ResistanceInfo_ViaResistance() : ResistanceInfo_ViaResistance(nullptr) {}
  ~ResistanceInfo_ViaResistance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResistanceInfo_ViaResistance(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResistanceInfo_ViaResistance(const ResistanceInfo_ViaResistance& from) : ResistanceInfo_ViaResistance(nullptr, from) {}
  inline ResistanceInfo_ViaResistance(ResistanceInfo_ViaResistance&& from) noexcept
      : ResistanceInfo_ViaResistance(nullptr, std::move(from)) {}
  inline ResistanceInfo_ViaResistance& operator=(const ResistanceInfo_ViaResistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResistanceInfo_ViaResistance& operator=(ResistanceInfo_ViaResistance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResistanceInfo_ViaResistance& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResistanceInfo_ViaResistance* internal_default_instance() {
    return reinterpret_cast<const ResistanceInfo_ViaResistance*>(
        &_ResistanceInfo_ViaResistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ResistanceInfo_ViaResistance& a, ResistanceInfo_ViaResistance& b) { a.Swap(&b); }
  inline void Swap(ResistanceInfo_ViaResistance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResistanceInfo_ViaResistance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResistanceInfo_ViaResistance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ResistanceInfo_ViaResistance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResistanceInfo_ViaResistance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResistanceInfo_ViaResistance& from) { ResistanceInfo_ViaResistance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResistanceInfo_ViaResistance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.ResistanceInfo.ViaResistance"; }

 protected:
  explicit ResistanceInfo_ViaResistance(::google::protobuf::Arena* arena);
  ResistanceInfo_ViaResistance(::google::protobuf::Arena* arena, const ResistanceInfo_ViaResistance& from);
  ResistanceInfo_ViaResistance(::google::protobuf::Arena* arena, ResistanceInfo_ViaResistance&& from) noexcept
      : ResistanceInfo_ViaResistance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kViaNameFieldNumber = 1,
    kResistanceFieldNumber = 2,
  };
  // string via_name = 1;
  void clear_via_name() ;
  const std::string& via_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_via_name(Arg_&& arg, Args_... args);
  std::string* mutable_via_name();
  PROTOBUF_NODISCARD std::string* release_via_name();
  void set_allocated_via_name(std::string* value);

  private:
  const std::string& _internal_via_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_via_name(
      const std::string& value);
  std::string* _internal_mutable_via_name();

  public:
  // double resistance = 2;
  void clear_resistance() ;
  double resistance() const;
  void set_resistance(double value);

  private:
  double _internal_resistance() const;
  void _internal_set_resistance(double value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.ResistanceInfo.ViaResistance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr via_name_;
    double resistance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class ResistanceInfo_LayerResistance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.ResistanceInfo.LayerResistance) */ {
 public:
  inline ResistanceInfo_LayerResistance() : ResistanceInfo_LayerResistance(nullptr) {}
  ~ResistanceInfo_LayerResistance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResistanceInfo_LayerResistance(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResistanceInfo_LayerResistance(const ResistanceInfo_LayerResistance& from) : ResistanceInfo_LayerResistance(nullptr, from) {}
  inline ResistanceInfo_LayerResistance(ResistanceInfo_LayerResistance&& from) noexcept
      : ResistanceInfo_LayerResistance(nullptr, std::move(from)) {}
  inline ResistanceInfo_LayerResistance& operator=(const ResistanceInfo_LayerResistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResistanceInfo_LayerResistance& operator=(ResistanceInfo_LayerResistance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResistanceInfo_LayerResistance& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResistanceInfo_LayerResistance* internal_default_instance() {
    return reinterpret_cast<const ResistanceInfo_LayerResistance*>(
        &_ResistanceInfo_LayerResistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ResistanceInfo_LayerResistance& a, ResistanceInfo_LayerResistance& b) { a.Swap(&b); }
  inline void Swap(ResistanceInfo_LayerResistance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResistanceInfo_LayerResistance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResistanceInfo_LayerResistance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ResistanceInfo_LayerResistance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResistanceInfo_LayerResistance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResistanceInfo_LayerResistance& from) { ResistanceInfo_LayerResistance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResistanceInfo_LayerResistance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.ResistanceInfo.LayerResistance"; }

 protected:
  explicit ResistanceInfo_LayerResistance(::google::protobuf::Arena* arena);
  ResistanceInfo_LayerResistance(::google::protobuf::Arena* arena, const ResistanceInfo_LayerResistance& from);
  ResistanceInfo_LayerResistance(::google::protobuf::Arena* arena, ResistanceInfo_LayerResistance&& from) noexcept
      : ResistanceInfo_LayerResistance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLayerNameFieldNumber = 1,
    kResistanceFieldNumber = 2,
    kCornerAdjustmentFractionFieldNumber = 3,
  };
  // string layer_name = 1;
  void clear_layer_name() ;
  const std::string& layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_layer_name();
  PROTOBUF_NODISCARD std::string* release_layer_name();
  void set_allocated_layer_name(std::string* value);

  private:
  const std::string& _internal_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layer_name(
      const std::string& value);
  std::string* _internal_mutable_layer_name();

  public:
  // double resistance = 2;
  void clear_resistance() ;
  double resistance() const;
  void set_resistance(double value);

  private:
  double _internal_resistance() const;
  void _internal_set_resistance(double value);

  public:
  // optional double corner_adjustment_fraction = 3;
  bool has_corner_adjustment_fraction() const;
  void clear_corner_adjustment_fraction() ;
  double corner_adjustment_fraction() const;
  void set_corner_adjustment_fraction(double value);

  private:
  double _internal_corner_adjustment_fraction() const;
  void _internal_set_corner_adjustment_fraction(double value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.ResistanceInfo.LayerResistance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr layer_name_;
    double resistance_;
    double corner_adjustment_fraction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class CapacitanceInfo_SubstrateCapacitance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.CapacitanceInfo.SubstrateCapacitance) */ {
 public:
  inline CapacitanceInfo_SubstrateCapacitance() : CapacitanceInfo_SubstrateCapacitance(nullptr) {}
  ~CapacitanceInfo_SubstrateCapacitance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapacitanceInfo_SubstrateCapacitance(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapacitanceInfo_SubstrateCapacitance(const CapacitanceInfo_SubstrateCapacitance& from) : CapacitanceInfo_SubstrateCapacitance(nullptr, from) {}
  inline CapacitanceInfo_SubstrateCapacitance(CapacitanceInfo_SubstrateCapacitance&& from) noexcept
      : CapacitanceInfo_SubstrateCapacitance(nullptr, std::move(from)) {}
  inline CapacitanceInfo_SubstrateCapacitance& operator=(const CapacitanceInfo_SubstrateCapacitance& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacitanceInfo_SubstrateCapacitance& operator=(CapacitanceInfo_SubstrateCapacitance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacitanceInfo_SubstrateCapacitance& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacitanceInfo_SubstrateCapacitance* internal_default_instance() {
    return reinterpret_cast<const CapacitanceInfo_SubstrateCapacitance*>(
        &_CapacitanceInfo_SubstrateCapacitance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(CapacitanceInfo_SubstrateCapacitance& a, CapacitanceInfo_SubstrateCapacitance& b) { a.Swap(&b); }
  inline void Swap(CapacitanceInfo_SubstrateCapacitance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacitanceInfo_SubstrateCapacitance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacitanceInfo_SubstrateCapacitance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CapacitanceInfo_SubstrateCapacitance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacitanceInfo_SubstrateCapacitance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapacitanceInfo_SubstrateCapacitance& from) { CapacitanceInfo_SubstrateCapacitance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapacitanceInfo_SubstrateCapacitance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.CapacitanceInfo.SubstrateCapacitance"; }

 protected:
  explicit CapacitanceInfo_SubstrateCapacitance(::google::protobuf::Arena* arena);
  CapacitanceInfo_SubstrateCapacitance(::google::protobuf::Arena* arena, const CapacitanceInfo_SubstrateCapacitance& from);
  CapacitanceInfo_SubstrateCapacitance(::google::protobuf::Arena* arena, CapacitanceInfo_SubstrateCapacitance&& from) noexcept
      : CapacitanceInfo_SubstrateCapacitance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLayerNameFieldNumber = 1,
    kAreaCapacitanceFieldNumber = 2,
    kPerimeterCapacitanceFieldNumber = 3,
  };
  // string layer_name = 1;
  void clear_layer_name() ;
  const std::string& layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_layer_name();
  PROTOBUF_NODISCARD std::string* release_layer_name();
  void set_allocated_layer_name(std::string* value);

  private:
  const std::string& _internal_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layer_name(
      const std::string& value);
  std::string* _internal_mutable_layer_name();

  public:
  // double area_capacitance = 2;
  void clear_area_capacitance() ;
  double area_capacitance() const;
  void set_area_capacitance(double value);

  private:
  double _internal_area_capacitance() const;
  void _internal_set_area_capacitance(double value);

  public:
  // double perimeter_capacitance = 3;
  void clear_perimeter_capacitance() ;
  double perimeter_capacitance() const;
  void set_perimeter_capacitance(double value);

  private:
  double _internal_perimeter_capacitance() const;
  void _internal_set_perimeter_capacitance(double value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.CapacitanceInfo.SubstrateCapacitance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr layer_name_;
    double area_capacitance_;
    double perimeter_capacitance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class CapacitanceInfo_SidewallCapacitance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.CapacitanceInfo.SidewallCapacitance) */ {
 public:
  inline CapacitanceInfo_SidewallCapacitance() : CapacitanceInfo_SidewallCapacitance(nullptr) {}
  ~CapacitanceInfo_SidewallCapacitance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapacitanceInfo_SidewallCapacitance(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapacitanceInfo_SidewallCapacitance(const CapacitanceInfo_SidewallCapacitance& from) : CapacitanceInfo_SidewallCapacitance(nullptr, from) {}
  inline CapacitanceInfo_SidewallCapacitance(CapacitanceInfo_SidewallCapacitance&& from) noexcept
      : CapacitanceInfo_SidewallCapacitance(nullptr, std::move(from)) {}
  inline CapacitanceInfo_SidewallCapacitance& operator=(const CapacitanceInfo_SidewallCapacitance& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacitanceInfo_SidewallCapacitance& operator=(CapacitanceInfo_SidewallCapacitance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacitanceInfo_SidewallCapacitance& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacitanceInfo_SidewallCapacitance* internal_default_instance() {
    return reinterpret_cast<const CapacitanceInfo_SidewallCapacitance*>(
        &_CapacitanceInfo_SidewallCapacitance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CapacitanceInfo_SidewallCapacitance& a, CapacitanceInfo_SidewallCapacitance& b) { a.Swap(&b); }
  inline void Swap(CapacitanceInfo_SidewallCapacitance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacitanceInfo_SidewallCapacitance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacitanceInfo_SidewallCapacitance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CapacitanceInfo_SidewallCapacitance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacitanceInfo_SidewallCapacitance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapacitanceInfo_SidewallCapacitance& from) { CapacitanceInfo_SidewallCapacitance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapacitanceInfo_SidewallCapacitance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.CapacitanceInfo.SidewallCapacitance"; }

 protected:
  explicit CapacitanceInfo_SidewallCapacitance(::google::protobuf::Arena* arena);
  CapacitanceInfo_SidewallCapacitance(::google::protobuf::Arena* arena, const CapacitanceInfo_SidewallCapacitance& from);
  CapacitanceInfo_SidewallCapacitance(::google::protobuf::Arena* arena, CapacitanceInfo_SidewallCapacitance&& from) noexcept
      : CapacitanceInfo_SidewallCapacitance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLayerNameFieldNumber = 1,
    kCapacitanceFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // string layer_name = 1;
  void clear_layer_name() ;
  const std::string& layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_layer_name();
  PROTOBUF_NODISCARD std::string* release_layer_name();
  void set_allocated_layer_name(std::string* value);

  private:
  const std::string& _internal_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layer_name(
      const std::string& value);
  std::string* _internal_mutable_layer_name();

  public:
  // double capacitance = 2;
  void clear_capacitance() ;
  double capacitance() const;
  void set_capacitance(double value);

  private:
  double _internal_capacitance() const;
  void _internal_set_capacitance(double value);

  public:
  // double offset = 3;
  void clear_offset() ;
  double offset() const;
  void set_offset(double value);

  private:
  double _internal_offset() const;
  void _internal_set_offset(double value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.CapacitanceInfo.SidewallCapacitance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr layer_name_;
    double capacitance_;
    double offset_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class CapacitanceInfo_SideOverlapCapacitance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.CapacitanceInfo.SideOverlapCapacitance) */ {
 public:
  inline CapacitanceInfo_SideOverlapCapacitance() : CapacitanceInfo_SideOverlapCapacitance(nullptr) {}
  ~CapacitanceInfo_SideOverlapCapacitance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapacitanceInfo_SideOverlapCapacitance(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapacitanceInfo_SideOverlapCapacitance(const CapacitanceInfo_SideOverlapCapacitance& from) : CapacitanceInfo_SideOverlapCapacitance(nullptr, from) {}
  inline CapacitanceInfo_SideOverlapCapacitance(CapacitanceInfo_SideOverlapCapacitance&& from) noexcept
      : CapacitanceInfo_SideOverlapCapacitance(nullptr, std::move(from)) {}
  inline CapacitanceInfo_SideOverlapCapacitance& operator=(const CapacitanceInfo_SideOverlapCapacitance& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacitanceInfo_SideOverlapCapacitance& operator=(CapacitanceInfo_SideOverlapCapacitance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacitanceInfo_SideOverlapCapacitance& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacitanceInfo_SideOverlapCapacitance* internal_default_instance() {
    return reinterpret_cast<const CapacitanceInfo_SideOverlapCapacitance*>(
        &_CapacitanceInfo_SideOverlapCapacitance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CapacitanceInfo_SideOverlapCapacitance& a, CapacitanceInfo_SideOverlapCapacitance& b) { a.Swap(&b); }
  inline void Swap(CapacitanceInfo_SideOverlapCapacitance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacitanceInfo_SideOverlapCapacitance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacitanceInfo_SideOverlapCapacitance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CapacitanceInfo_SideOverlapCapacitance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacitanceInfo_SideOverlapCapacitance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapacitanceInfo_SideOverlapCapacitance& from) { CapacitanceInfo_SideOverlapCapacitance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapacitanceInfo_SideOverlapCapacitance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.CapacitanceInfo.SideOverlapCapacitance"; }

 protected:
  explicit CapacitanceInfo_SideOverlapCapacitance(::google::protobuf::Arena* arena);
  CapacitanceInfo_SideOverlapCapacitance(::google::protobuf::Arena* arena, const CapacitanceInfo_SideOverlapCapacitance& from);
  CapacitanceInfo_SideOverlapCapacitance(::google::protobuf::Arena* arena, CapacitanceInfo_SideOverlapCapacitance&& from) noexcept
      : CapacitanceInfo_SideOverlapCapacitance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInLayerNameFieldNumber = 1,
    kOutLayerNameFieldNumber = 2,
    kCapacitanceFieldNumber = 3,
  };
  // string in_layer_name = 1;
  void clear_in_layer_name() ;
  const std::string& in_layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_in_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_in_layer_name();
  PROTOBUF_NODISCARD std::string* release_in_layer_name();
  void set_allocated_in_layer_name(std::string* value);

  private:
  const std::string& _internal_in_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_in_layer_name(
      const std::string& value);
  std::string* _internal_mutable_in_layer_name();

  public:
  // string out_layer_name = 2;
  void clear_out_layer_name() ;
  const std::string& out_layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_out_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_out_layer_name();
  PROTOBUF_NODISCARD std::string* release_out_layer_name();
  void set_allocated_out_layer_name(std::string* value);

  private:
  const std::string& _internal_out_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out_layer_name(
      const std::string& value);
  std::string* _internal_mutable_out_layer_name();

  public:
  // double capacitance = 3;
  void clear_capacitance() ;
  double capacitance() const;
  void set_capacitance(double value);

  private:
  double _internal_capacitance() const;
  void _internal_set_capacitance(double value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.CapacitanceInfo.SideOverlapCapacitance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr in_layer_name_;
    ::google::protobuf::internal::ArenaStringPtr out_layer_name_;
    double capacitance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class CapacitanceInfo_OverlapCapacitance final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.CapacitanceInfo.OverlapCapacitance) */ {
 public:
  inline CapacitanceInfo_OverlapCapacitance() : CapacitanceInfo_OverlapCapacitance(nullptr) {}
  ~CapacitanceInfo_OverlapCapacitance() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapacitanceInfo_OverlapCapacitance(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapacitanceInfo_OverlapCapacitance(const CapacitanceInfo_OverlapCapacitance& from) : CapacitanceInfo_OverlapCapacitance(nullptr, from) {}
  inline CapacitanceInfo_OverlapCapacitance(CapacitanceInfo_OverlapCapacitance&& from) noexcept
      : CapacitanceInfo_OverlapCapacitance(nullptr, std::move(from)) {}
  inline CapacitanceInfo_OverlapCapacitance& operator=(const CapacitanceInfo_OverlapCapacitance& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacitanceInfo_OverlapCapacitance& operator=(CapacitanceInfo_OverlapCapacitance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacitanceInfo_OverlapCapacitance& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacitanceInfo_OverlapCapacitance* internal_default_instance() {
    return reinterpret_cast<const CapacitanceInfo_OverlapCapacitance*>(
        &_CapacitanceInfo_OverlapCapacitance_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CapacitanceInfo_OverlapCapacitance& a, CapacitanceInfo_OverlapCapacitance& b) { a.Swap(&b); }
  inline void Swap(CapacitanceInfo_OverlapCapacitance* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacitanceInfo_OverlapCapacitance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacitanceInfo_OverlapCapacitance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CapacitanceInfo_OverlapCapacitance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacitanceInfo_OverlapCapacitance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapacitanceInfo_OverlapCapacitance& from) { CapacitanceInfo_OverlapCapacitance::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapacitanceInfo_OverlapCapacitance* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.CapacitanceInfo.OverlapCapacitance"; }

 protected:
  explicit CapacitanceInfo_OverlapCapacitance(::google::protobuf::Arena* arena);
  CapacitanceInfo_OverlapCapacitance(::google::protobuf::Arena* arena, const CapacitanceInfo_OverlapCapacitance& from);
  CapacitanceInfo_OverlapCapacitance(::google::protobuf::Arena* arena, CapacitanceInfo_OverlapCapacitance&& from) noexcept
      : CapacitanceInfo_OverlapCapacitance(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopLayerNameFieldNumber = 1,
    kBottomLayerNameFieldNumber = 2,
    kCapacitanceFieldNumber = 3,
  };
  // string top_layer_name = 1;
  void clear_top_layer_name() ;
  const std::string& top_layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_top_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_top_layer_name();
  PROTOBUF_NODISCARD std::string* release_top_layer_name();
  void set_allocated_top_layer_name(std::string* value);

  private:
  const std::string& _internal_top_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_top_layer_name(
      const std::string& value);
  std::string* _internal_mutable_top_layer_name();

  public:
  // string bottom_layer_name = 2;
  void clear_bottom_layer_name() ;
  const std::string& bottom_layer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bottom_layer_name(Arg_&& arg, Args_... args);
  std::string* mutable_bottom_layer_name();
  PROTOBUF_NODISCARD std::string* release_bottom_layer_name();
  void set_allocated_bottom_layer_name(std::string* value);

  private:
  const std::string& _internal_bottom_layer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bottom_layer_name(
      const std::string& value);
  std::string* _internal_mutable_bottom_layer_name();

  public:
  // double capacitance = 3;
  void clear_capacitance() ;
  double capacitance() const;
  void set_capacitance(double value);

  private:
  double _internal_capacitance() const;
  void _internal_set_capacitance(double value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.CapacitanceInfo.OverlapCapacitance)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr top_layer_name_;
    ::google::protobuf::internal::ArenaStringPtr bottom_layer_name_;
    double capacitance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class ResistanceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.ResistanceInfo) */ {
 public:
  inline ResistanceInfo() : ResistanceInfo(nullptr) {}
  ~ResistanceInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResistanceInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ResistanceInfo(const ResistanceInfo& from) : ResistanceInfo(nullptr, from) {}
  inline ResistanceInfo(ResistanceInfo&& from) noexcept
      : ResistanceInfo(nullptr, std::move(from)) {}
  inline ResistanceInfo& operator=(const ResistanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResistanceInfo& operator=(ResistanceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResistanceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResistanceInfo* internal_default_instance() {
    return reinterpret_cast<const ResistanceInfo*>(
        &_ResistanceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ResistanceInfo& a, ResistanceInfo& b) { a.Swap(&b); }
  inline void Swap(ResistanceInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResistanceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResistanceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ResistanceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResistanceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResistanceInfo& from) { ResistanceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ResistanceInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.ResistanceInfo"; }

 protected:
  explicit ResistanceInfo(::google::protobuf::Arena* arena);
  ResistanceInfo(::google::protobuf::Arena* arena, const ResistanceInfo& from);
  ResistanceInfo(::google::protobuf::Arena* arena, ResistanceInfo&& from) noexcept
      : ResistanceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using LayerResistance = ResistanceInfo_LayerResistance;
  using ViaResistance = ResistanceInfo_ViaResistance;

  // accessors -------------------------------------------------------
  enum : int {
    kLayersFieldNumber = 1,
    kViasFieldNumber = 2,
  };
  // repeated .kpex.tech.ResistanceInfo.LayerResistance layers = 1;
  int layers_size() const;
  private:
  int _internal_layers_size() const;

  public:
  void clear_layers() ;
  ::kpex::tech::ResistanceInfo_LayerResistance* mutable_layers(int index);
  ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>* mutable_layers();

  private:
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>& _internal_layers() const;
  ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>* _internal_mutable_layers();
  public:
  const ::kpex::tech::ResistanceInfo_LayerResistance& layers(int index) const;
  ::kpex::tech::ResistanceInfo_LayerResistance* add_layers();
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>& layers() const;
  // repeated .kpex.tech.ResistanceInfo.ViaResistance vias = 2;
  int vias_size() const;
  private:
  int _internal_vias_size() const;

  public:
  void clear_vias() ;
  ::kpex::tech::ResistanceInfo_ViaResistance* mutable_vias(int index);
  ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>* mutable_vias();

  private:
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>& _internal_vias() const;
  ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>* _internal_mutable_vias();
  public:
  const ::kpex::tech::ResistanceInfo_ViaResistance& vias(int index) const;
  ::kpex::tech::ResistanceInfo_ViaResistance* add_vias();
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>& vias() const;
  // @@protoc_insertion_point(class_scope:kpex.tech.ResistanceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::kpex::tech::ResistanceInfo_LayerResistance > layers_;
    ::google::protobuf::RepeatedPtrField< ::kpex::tech::ResistanceInfo_ViaResistance > vias_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class CapacitanceInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.CapacitanceInfo) */ {
 public:
  inline CapacitanceInfo() : CapacitanceInfo(nullptr) {}
  ~CapacitanceInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CapacitanceInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CapacitanceInfo(const CapacitanceInfo& from) : CapacitanceInfo(nullptr, from) {}
  inline CapacitanceInfo(CapacitanceInfo&& from) noexcept
      : CapacitanceInfo(nullptr, std::move(from)) {}
  inline CapacitanceInfo& operator=(const CapacitanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacitanceInfo& operator=(CapacitanceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacitanceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacitanceInfo* internal_default_instance() {
    return reinterpret_cast<const CapacitanceInfo*>(
        &_CapacitanceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CapacitanceInfo& a, CapacitanceInfo& b) { a.Swap(&b); }
  inline void Swap(CapacitanceInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacitanceInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacitanceInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CapacitanceInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacitanceInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CapacitanceInfo& from) { CapacitanceInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapacitanceInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.CapacitanceInfo"; }

 protected:
  explicit CapacitanceInfo(::google::protobuf::Arena* arena);
  CapacitanceInfo(::google::protobuf::Arena* arena, const CapacitanceInfo& from);
  CapacitanceInfo(::google::protobuf::Arena* arena, CapacitanceInfo&& from) noexcept
      : CapacitanceInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using SubstrateCapacitance = CapacitanceInfo_SubstrateCapacitance;
  using OverlapCapacitance = CapacitanceInfo_OverlapCapacitance;
  using SidewallCapacitance = CapacitanceInfo_SidewallCapacitance;
  using SideOverlapCapacitance = CapacitanceInfo_SideOverlapCapacitance;

  // accessors -------------------------------------------------------
  enum : int {
    kSubstratesFieldNumber = 200,
    kOverlapsFieldNumber = 201,
    kSidewallsFieldNumber = 202,
    kSideoverlapsFieldNumber = 203,
  };
  // repeated .kpex.tech.CapacitanceInfo.SubstrateCapacitance substrates = 200;
  int substrates_size() const;
  private:
  int _internal_substrates_size() const;

  public:
  void clear_substrates() ;
  ::kpex::tech::CapacitanceInfo_SubstrateCapacitance* mutable_substrates(int index);
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>* mutable_substrates();

  private:
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>& _internal_substrates() const;
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>* _internal_mutable_substrates();
  public:
  const ::kpex::tech::CapacitanceInfo_SubstrateCapacitance& substrates(int index) const;
  ::kpex::tech::CapacitanceInfo_SubstrateCapacitance* add_substrates();
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>& substrates() const;
  // repeated .kpex.tech.CapacitanceInfo.OverlapCapacitance overlaps = 201;
  int overlaps_size() const;
  private:
  int _internal_overlaps_size() const;

  public:
  void clear_overlaps() ;
  ::kpex::tech::CapacitanceInfo_OverlapCapacitance* mutable_overlaps(int index);
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>* mutable_overlaps();

  private:
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>& _internal_overlaps() const;
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>* _internal_mutable_overlaps();
  public:
  const ::kpex::tech::CapacitanceInfo_OverlapCapacitance& overlaps(int index) const;
  ::kpex::tech::CapacitanceInfo_OverlapCapacitance* add_overlaps();
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>& overlaps() const;
  // repeated .kpex.tech.CapacitanceInfo.SidewallCapacitance sidewalls = 202;
  int sidewalls_size() const;
  private:
  int _internal_sidewalls_size() const;

  public:
  void clear_sidewalls() ;
  ::kpex::tech::CapacitanceInfo_SidewallCapacitance* mutable_sidewalls(int index);
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>* mutable_sidewalls();

  private:
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>& _internal_sidewalls() const;
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>* _internal_mutable_sidewalls();
  public:
  const ::kpex::tech::CapacitanceInfo_SidewallCapacitance& sidewalls(int index) const;
  ::kpex::tech::CapacitanceInfo_SidewallCapacitance* add_sidewalls();
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>& sidewalls() const;
  // repeated .kpex.tech.CapacitanceInfo.SideOverlapCapacitance sideoverlaps = 203;
  int sideoverlaps_size() const;
  private:
  int _internal_sideoverlaps_size() const;

  public:
  void clear_sideoverlaps() ;
  ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance* mutable_sideoverlaps(int index);
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>* mutable_sideoverlaps();

  private:
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>& _internal_sideoverlaps() const;
  ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>* _internal_mutable_sideoverlaps();
  public:
  const ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance& sideoverlaps(int index) const;
  ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance* add_sideoverlaps();
  const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>& sideoverlaps() const;
  // @@protoc_insertion_point(class_scope:kpex.tech.CapacitanceInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::kpex::tech::CapacitanceInfo_SubstrateCapacitance > substrates_;
    ::google::protobuf::RepeatedPtrField< ::kpex::tech::CapacitanceInfo_OverlapCapacitance > overlaps_;
    ::google::protobuf::RepeatedPtrField< ::kpex::tech::CapacitanceInfo_SidewallCapacitance > sidewalls_;
    ::google::protobuf::RepeatedPtrField< ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance > sideoverlaps_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};
// -------------------------------------------------------------------

class ExtractionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kpex.tech.ExtractionInfo) */ {
 public:
  inline ExtractionInfo() : ExtractionInfo(nullptr) {}
  ~ExtractionInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtractionInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtractionInfo(const ExtractionInfo& from) : ExtractionInfo(nullptr, from) {}
  inline ExtractionInfo(ExtractionInfo&& from) noexcept
      : ExtractionInfo(nullptr, std::move(from)) {}
  inline ExtractionInfo& operator=(const ExtractionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtractionInfo& operator=(ExtractionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtractionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtractionInfo* internal_default_instance() {
    return reinterpret_cast<const ExtractionInfo*>(
        &_ExtractionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ExtractionInfo& a, ExtractionInfo& b) { a.Swap(&b); }
  inline void Swap(ExtractionInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtractionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtractionInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExtractionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtractionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtractionInfo& from) { ExtractionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExtractionInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kpex.tech.ExtractionInfo"; }

 protected:
  explicit ExtractionInfo(::google::protobuf::Arena* arena);
  ExtractionInfo(::google::protobuf::Arena* arena, const ExtractionInfo& from);
  ExtractionInfo(::google::protobuf::Arena* arena, ExtractionInfo&& from) noexcept
      : ExtractionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kResistanceFieldNumber = 110,
    kCapacitanceFieldNumber = 111,
    kSideHaloFieldNumber = 10,
    kFringeShieldHaloFieldNumber = 11,
  };
  // .kpex.tech.ResistanceInfo resistance = 110;
  bool has_resistance() const;
  void clear_resistance() ;
  const ::kpex::tech::ResistanceInfo& resistance() const;
  PROTOBUF_NODISCARD ::kpex::tech::ResistanceInfo* release_resistance();
  ::kpex::tech::ResistanceInfo* mutable_resistance();
  void set_allocated_resistance(::kpex::tech::ResistanceInfo* value);
  void unsafe_arena_set_allocated_resistance(::kpex::tech::ResistanceInfo* value);
  ::kpex::tech::ResistanceInfo* unsafe_arena_release_resistance();

  private:
  const ::kpex::tech::ResistanceInfo& _internal_resistance() const;
  ::kpex::tech::ResistanceInfo* _internal_mutable_resistance();

  public:
  // .kpex.tech.CapacitanceInfo capacitance = 111;
  bool has_capacitance() const;
  void clear_capacitance() ;
  const ::kpex::tech::CapacitanceInfo& capacitance() const;
  PROTOBUF_NODISCARD ::kpex::tech::CapacitanceInfo* release_capacitance();
  ::kpex::tech::CapacitanceInfo* mutable_capacitance();
  void set_allocated_capacitance(::kpex::tech::CapacitanceInfo* value);
  void unsafe_arena_set_allocated_capacitance(::kpex::tech::CapacitanceInfo* value);
  ::kpex::tech::CapacitanceInfo* unsafe_arena_release_capacitance();

  private:
  const ::kpex::tech::CapacitanceInfo& _internal_capacitance() const;
  ::kpex::tech::CapacitanceInfo* _internal_mutable_capacitance();

  public:
  // int32 side_halo = 10;
  void clear_side_halo() ;
  ::int32_t side_halo() const;
  void set_side_halo(::int32_t value);

  private:
  ::int32_t _internal_side_halo() const;
  void _internal_set_side_halo(::int32_t value);

  public:
  // int32 fringe_shield_halo = 11;
  void clear_fringe_shield_halo() ;
  ::int32_t fringe_shield_halo() const;
  void set_fringe_shield_halo(::int32_t value);

  private:
  ::int32_t _internal_fringe_shield_halo() const;
  void _internal_set_fringe_shield_halo(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:kpex.tech.ExtractionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 2,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::kpex::tech::ResistanceInfo* resistance_;
    ::kpex::tech::CapacitanceInfo* capacitance_;
    ::int32_t side_halo_;
    ::int32_t fringe_shield_halo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_extract_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ExtractionInfo

// int32 side_halo = 10;
inline void ExtractionInfo::clear_side_halo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_halo_ = 0;
}
inline ::int32_t ExtractionInfo::side_halo() const {
  // @@protoc_insertion_point(field_get:kpex.tech.ExtractionInfo.side_halo)
  return _internal_side_halo();
}
inline void ExtractionInfo::set_side_halo(::int32_t value) {
  _internal_set_side_halo(value);
  // @@protoc_insertion_point(field_set:kpex.tech.ExtractionInfo.side_halo)
}
inline ::int32_t ExtractionInfo::_internal_side_halo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.side_halo_;
}
inline void ExtractionInfo::_internal_set_side_halo(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_halo_ = value;
}

// int32 fringe_shield_halo = 11;
inline void ExtractionInfo::clear_fringe_shield_halo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fringe_shield_halo_ = 0;
}
inline ::int32_t ExtractionInfo::fringe_shield_halo() const {
  // @@protoc_insertion_point(field_get:kpex.tech.ExtractionInfo.fringe_shield_halo)
  return _internal_fringe_shield_halo();
}
inline void ExtractionInfo::set_fringe_shield_halo(::int32_t value) {
  _internal_set_fringe_shield_halo(value);
  // @@protoc_insertion_point(field_set:kpex.tech.ExtractionInfo.fringe_shield_halo)
}
inline ::int32_t ExtractionInfo::_internal_fringe_shield_halo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fringe_shield_halo_;
}
inline void ExtractionInfo::_internal_set_fringe_shield_halo(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fringe_shield_halo_ = value;
}

// .kpex.tech.ResistanceInfo resistance = 110;
inline bool ExtractionInfo::has_resistance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resistance_ != nullptr);
  return value;
}
inline void ExtractionInfo::clear_resistance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.resistance_ != nullptr) _impl_.resistance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kpex::tech::ResistanceInfo& ExtractionInfo::_internal_resistance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kpex::tech::ResistanceInfo* p = _impl_.resistance_;
  return p != nullptr ? *p : reinterpret_cast<const ::kpex::tech::ResistanceInfo&>(::kpex::tech::_ResistanceInfo_default_instance_);
}
inline const ::kpex::tech::ResistanceInfo& ExtractionInfo::resistance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.ExtractionInfo.resistance)
  return _internal_resistance();
}
inline void ExtractionInfo::unsafe_arena_set_allocated_resistance(::kpex::tech::ResistanceInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.resistance_);
  }
  _impl_.resistance_ = reinterpret_cast<::kpex::tech::ResistanceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kpex.tech.ExtractionInfo.resistance)
}
inline ::kpex::tech::ResistanceInfo* ExtractionInfo::release_resistance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kpex::tech::ResistanceInfo* released = _impl_.resistance_;
  _impl_.resistance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kpex::tech::ResistanceInfo* ExtractionInfo::unsafe_arena_release_resistance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.ExtractionInfo.resistance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kpex::tech::ResistanceInfo* temp = _impl_.resistance_;
  _impl_.resistance_ = nullptr;
  return temp;
}
inline ::kpex::tech::ResistanceInfo* ExtractionInfo::_internal_mutable_resistance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.resistance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kpex::tech::ResistanceInfo>(GetArena());
    _impl_.resistance_ = reinterpret_cast<::kpex::tech::ResistanceInfo*>(p);
  }
  return _impl_.resistance_;
}
inline ::kpex::tech::ResistanceInfo* ExtractionInfo::mutable_resistance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kpex::tech::ResistanceInfo* _msg = _internal_mutable_resistance();
  // @@protoc_insertion_point(field_mutable:kpex.tech.ExtractionInfo.resistance)
  return _msg;
}
inline void ExtractionInfo::set_allocated_resistance(::kpex::tech::ResistanceInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.resistance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.resistance_ = reinterpret_cast<::kpex::tech::ResistanceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.ExtractionInfo.resistance)
}

// .kpex.tech.CapacitanceInfo capacitance = 111;
inline bool ExtractionInfo::has_capacitance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capacitance_ != nullptr);
  return value;
}
inline void ExtractionInfo::clear_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.capacitance_ != nullptr) _impl_.capacitance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kpex::tech::CapacitanceInfo& ExtractionInfo::_internal_capacitance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kpex::tech::CapacitanceInfo* p = _impl_.capacitance_;
  return p != nullptr ? *p : reinterpret_cast<const ::kpex::tech::CapacitanceInfo&>(::kpex::tech::_CapacitanceInfo_default_instance_);
}
inline const ::kpex::tech::CapacitanceInfo& ExtractionInfo::capacitance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.ExtractionInfo.capacitance)
  return _internal_capacitance();
}
inline void ExtractionInfo::unsafe_arena_set_allocated_capacitance(::kpex::tech::CapacitanceInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacitance_);
  }
  _impl_.capacitance_ = reinterpret_cast<::kpex::tech::CapacitanceInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kpex.tech.ExtractionInfo.capacitance)
}
inline ::kpex::tech::CapacitanceInfo* ExtractionInfo::release_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kpex::tech::CapacitanceInfo* released = _impl_.capacitance_;
  _impl_.capacitance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kpex::tech::CapacitanceInfo* ExtractionInfo::unsafe_arena_release_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.ExtractionInfo.capacitance)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kpex::tech::CapacitanceInfo* temp = _impl_.capacitance_;
  _impl_.capacitance_ = nullptr;
  return temp;
}
inline ::kpex::tech::CapacitanceInfo* ExtractionInfo::_internal_mutable_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.capacitance_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kpex::tech::CapacitanceInfo>(GetArena());
    _impl_.capacitance_ = reinterpret_cast<::kpex::tech::CapacitanceInfo*>(p);
  }
  return _impl_.capacitance_;
}
inline ::kpex::tech::CapacitanceInfo* ExtractionInfo::mutable_capacitance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kpex::tech::CapacitanceInfo* _msg = _internal_mutable_capacitance();
  // @@protoc_insertion_point(field_mutable:kpex.tech.ExtractionInfo.capacitance)
  return _msg;
}
inline void ExtractionInfo::set_allocated_capacitance(::kpex::tech::CapacitanceInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.capacitance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.capacitance_ = reinterpret_cast<::kpex::tech::CapacitanceInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.ExtractionInfo.capacitance)
}

// -------------------------------------------------------------------

// ResistanceInfo_LayerResistance

// string layer_name = 1;
inline void ResistanceInfo_LayerResistance::clear_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.ClearToEmpty();
}
inline const std::string& ResistanceInfo_LayerResistance::layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.LayerResistance.layer_name)
  return _internal_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResistanceInfo_LayerResistance::set_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.ResistanceInfo.LayerResistance.layer_name)
}
inline std::string* ResistanceInfo_LayerResistance::mutable_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.ResistanceInfo.LayerResistance.layer_name)
  return _s;
}
inline const std::string& ResistanceInfo_LayerResistance::_internal_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.layer_name_.Get();
}
inline void ResistanceInfo_LayerResistance::_internal_set_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.Set(value, GetArena());
}
inline std::string* ResistanceInfo_LayerResistance::_internal_mutable_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.layer_name_.Mutable( GetArena());
}
inline std::string* ResistanceInfo_LayerResistance::release_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.ResistanceInfo.LayerResistance.layer_name)
  return _impl_.layer_name_.Release();
}
inline void ResistanceInfo_LayerResistance::set_allocated_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.layer_name_.IsDefault()) {
          _impl_.layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.ResistanceInfo.LayerResistance.layer_name)
}

// double resistance = 2;
inline void ResistanceInfo_LayerResistance::clear_resistance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resistance_ = 0;
}
inline double ResistanceInfo_LayerResistance::resistance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.LayerResistance.resistance)
  return _internal_resistance();
}
inline void ResistanceInfo_LayerResistance::set_resistance(double value) {
  _internal_set_resistance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.ResistanceInfo.LayerResistance.resistance)
}
inline double ResistanceInfo_LayerResistance::_internal_resistance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resistance_;
}
inline void ResistanceInfo_LayerResistance::_internal_set_resistance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resistance_ = value;
}

// optional double corner_adjustment_fraction = 3;
inline bool ResistanceInfo_LayerResistance::has_corner_adjustment_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ResistanceInfo_LayerResistance::clear_corner_adjustment_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.corner_adjustment_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ResistanceInfo_LayerResistance::corner_adjustment_fraction() const {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.LayerResistance.corner_adjustment_fraction)
  return _internal_corner_adjustment_fraction();
}
inline void ResistanceInfo_LayerResistance::set_corner_adjustment_fraction(double value) {
  _internal_set_corner_adjustment_fraction(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:kpex.tech.ResistanceInfo.LayerResistance.corner_adjustment_fraction)
}
inline double ResistanceInfo_LayerResistance::_internal_corner_adjustment_fraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.corner_adjustment_fraction_;
}
inline void ResistanceInfo_LayerResistance::_internal_set_corner_adjustment_fraction(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.corner_adjustment_fraction_ = value;
}

// -------------------------------------------------------------------

// ResistanceInfo_ViaResistance

// string via_name = 1;
inline void ResistanceInfo_ViaResistance::clear_via_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.via_name_.ClearToEmpty();
}
inline const std::string& ResistanceInfo_ViaResistance::via_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.ViaResistance.via_name)
  return _internal_via_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResistanceInfo_ViaResistance::set_via_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.via_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.ResistanceInfo.ViaResistance.via_name)
}
inline std::string* ResistanceInfo_ViaResistance::mutable_via_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_via_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.ResistanceInfo.ViaResistance.via_name)
  return _s;
}
inline const std::string& ResistanceInfo_ViaResistance::_internal_via_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.via_name_.Get();
}
inline void ResistanceInfo_ViaResistance::_internal_set_via_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.via_name_.Set(value, GetArena());
}
inline std::string* ResistanceInfo_ViaResistance::_internal_mutable_via_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.via_name_.Mutable( GetArena());
}
inline std::string* ResistanceInfo_ViaResistance::release_via_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.ResistanceInfo.ViaResistance.via_name)
  return _impl_.via_name_.Release();
}
inline void ResistanceInfo_ViaResistance::set_allocated_via_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.via_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.via_name_.IsDefault()) {
          _impl_.via_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.ResistanceInfo.ViaResistance.via_name)
}

// double resistance = 2;
inline void ResistanceInfo_ViaResistance::clear_resistance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resistance_ = 0;
}
inline double ResistanceInfo_ViaResistance::resistance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.ViaResistance.resistance)
  return _internal_resistance();
}
inline void ResistanceInfo_ViaResistance::set_resistance(double value) {
  _internal_set_resistance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.ResistanceInfo.ViaResistance.resistance)
}
inline double ResistanceInfo_ViaResistance::_internal_resistance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resistance_;
}
inline void ResistanceInfo_ViaResistance::_internal_set_resistance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resistance_ = value;
}

// -------------------------------------------------------------------

// ResistanceInfo

// repeated .kpex.tech.ResistanceInfo.LayerResistance layers = 1;
inline int ResistanceInfo::_internal_layers_size() const {
  return _internal_layers().size();
}
inline int ResistanceInfo::layers_size() const {
  return _internal_layers_size();
}
inline void ResistanceInfo::clear_layers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layers_.Clear();
}
inline ::kpex::tech::ResistanceInfo_LayerResistance* ResistanceInfo::mutable_layers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kpex.tech.ResistanceInfo.layers)
  return _internal_mutable_layers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>* ResistanceInfo::mutable_layers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kpex.tech.ResistanceInfo.layers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_layers();
}
inline const ::kpex::tech::ResistanceInfo_LayerResistance& ResistanceInfo::layers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.layers)
  return _internal_layers().Get(index);
}
inline ::kpex::tech::ResistanceInfo_LayerResistance* ResistanceInfo::add_layers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::kpex::tech::ResistanceInfo_LayerResistance* _add = _internal_mutable_layers()->Add();
  // @@protoc_insertion_point(field_add:kpex.tech.ResistanceInfo.layers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>& ResistanceInfo::layers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kpex.tech.ResistanceInfo.layers)
  return _internal_layers();
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>&
ResistanceInfo::_internal_layers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.layers_;
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_LayerResistance>*
ResistanceInfo::_internal_mutable_layers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.layers_;
}

// repeated .kpex.tech.ResistanceInfo.ViaResistance vias = 2;
inline int ResistanceInfo::_internal_vias_size() const {
  return _internal_vias().size();
}
inline int ResistanceInfo::vias_size() const {
  return _internal_vias_size();
}
inline void ResistanceInfo::clear_vias() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vias_.Clear();
}
inline ::kpex::tech::ResistanceInfo_ViaResistance* ResistanceInfo::mutable_vias(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kpex.tech.ResistanceInfo.vias)
  return _internal_mutable_vias()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>* ResistanceInfo::mutable_vias()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kpex.tech.ResistanceInfo.vias)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vias();
}
inline const ::kpex::tech::ResistanceInfo_ViaResistance& ResistanceInfo::vias(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.ResistanceInfo.vias)
  return _internal_vias().Get(index);
}
inline ::kpex::tech::ResistanceInfo_ViaResistance* ResistanceInfo::add_vias() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::kpex::tech::ResistanceInfo_ViaResistance* _add = _internal_mutable_vias()->Add();
  // @@protoc_insertion_point(field_add:kpex.tech.ResistanceInfo.vias)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>& ResistanceInfo::vias() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kpex.tech.ResistanceInfo.vias)
  return _internal_vias();
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>&
ResistanceInfo::_internal_vias() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vias_;
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::ResistanceInfo_ViaResistance>*
ResistanceInfo::_internal_mutable_vias() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vias_;
}

// -------------------------------------------------------------------

// CapacitanceInfo_SubstrateCapacitance

// string layer_name = 1;
inline void CapacitanceInfo_SubstrateCapacitance::clear_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.ClearToEmpty();
}
inline const std::string& CapacitanceInfo_SubstrateCapacitance::layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SubstrateCapacitance.layer_name)
  return _internal_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacitanceInfo_SubstrateCapacitance::set_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SubstrateCapacitance.layer_name)
}
inline std::string* CapacitanceInfo_SubstrateCapacitance::mutable_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.SubstrateCapacitance.layer_name)
  return _s;
}
inline const std::string& CapacitanceInfo_SubstrateCapacitance::_internal_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.layer_name_.Get();
}
inline void CapacitanceInfo_SubstrateCapacitance::_internal_set_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.Set(value, GetArena());
}
inline std::string* CapacitanceInfo_SubstrateCapacitance::_internal_mutable_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.layer_name_.Mutable( GetArena());
}
inline std::string* CapacitanceInfo_SubstrateCapacitance::release_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.CapacitanceInfo.SubstrateCapacitance.layer_name)
  return _impl_.layer_name_.Release();
}
inline void CapacitanceInfo_SubstrateCapacitance::set_allocated_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.layer_name_.IsDefault()) {
          _impl_.layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.CapacitanceInfo.SubstrateCapacitance.layer_name)
}

// double area_capacitance = 2;
inline void CapacitanceInfo_SubstrateCapacitance::clear_area_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.area_capacitance_ = 0;
}
inline double CapacitanceInfo_SubstrateCapacitance::area_capacitance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SubstrateCapacitance.area_capacitance)
  return _internal_area_capacitance();
}
inline void CapacitanceInfo_SubstrateCapacitance::set_area_capacitance(double value) {
  _internal_set_area_capacitance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SubstrateCapacitance.area_capacitance)
}
inline double CapacitanceInfo_SubstrateCapacitance::_internal_area_capacitance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.area_capacitance_;
}
inline void CapacitanceInfo_SubstrateCapacitance::_internal_set_area_capacitance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.area_capacitance_ = value;
}

// double perimeter_capacitance = 3;
inline void CapacitanceInfo_SubstrateCapacitance::clear_perimeter_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perimeter_capacitance_ = 0;
}
inline double CapacitanceInfo_SubstrateCapacitance::perimeter_capacitance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SubstrateCapacitance.perimeter_capacitance)
  return _internal_perimeter_capacitance();
}
inline void CapacitanceInfo_SubstrateCapacitance::set_perimeter_capacitance(double value) {
  _internal_set_perimeter_capacitance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SubstrateCapacitance.perimeter_capacitance)
}
inline double CapacitanceInfo_SubstrateCapacitance::_internal_perimeter_capacitance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.perimeter_capacitance_;
}
inline void CapacitanceInfo_SubstrateCapacitance::_internal_set_perimeter_capacitance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.perimeter_capacitance_ = value;
}

// -------------------------------------------------------------------

// CapacitanceInfo_OverlapCapacitance

// string top_layer_name = 1;
inline void CapacitanceInfo_OverlapCapacitance::clear_top_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_layer_name_.ClearToEmpty();
}
inline const std::string& CapacitanceInfo_OverlapCapacitance::top_layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.OverlapCapacitance.top_layer_name)
  return _internal_top_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacitanceInfo_OverlapCapacitance::set_top_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.OverlapCapacitance.top_layer_name)
}
inline std::string* CapacitanceInfo_OverlapCapacitance::mutable_top_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_top_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.OverlapCapacitance.top_layer_name)
  return _s;
}
inline const std::string& CapacitanceInfo_OverlapCapacitance::_internal_top_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_layer_name_.Get();
}
inline void CapacitanceInfo_OverlapCapacitance::_internal_set_top_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_layer_name_.Set(value, GetArena());
}
inline std::string* CapacitanceInfo_OverlapCapacitance::_internal_mutable_top_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.top_layer_name_.Mutable( GetArena());
}
inline std::string* CapacitanceInfo_OverlapCapacitance::release_top_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.CapacitanceInfo.OverlapCapacitance.top_layer_name)
  return _impl_.top_layer_name_.Release();
}
inline void CapacitanceInfo_OverlapCapacitance::set_allocated_top_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.top_layer_name_.IsDefault()) {
          _impl_.top_layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.CapacitanceInfo.OverlapCapacitance.top_layer_name)
}

// string bottom_layer_name = 2;
inline void CapacitanceInfo_OverlapCapacitance::clear_bottom_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bottom_layer_name_.ClearToEmpty();
}
inline const std::string& CapacitanceInfo_OverlapCapacitance::bottom_layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.OverlapCapacitance.bottom_layer_name)
  return _internal_bottom_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacitanceInfo_OverlapCapacitance::set_bottom_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bottom_layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.OverlapCapacitance.bottom_layer_name)
}
inline std::string* CapacitanceInfo_OverlapCapacitance::mutable_bottom_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bottom_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.OverlapCapacitance.bottom_layer_name)
  return _s;
}
inline const std::string& CapacitanceInfo_OverlapCapacitance::_internal_bottom_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bottom_layer_name_.Get();
}
inline void CapacitanceInfo_OverlapCapacitance::_internal_set_bottom_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bottom_layer_name_.Set(value, GetArena());
}
inline std::string* CapacitanceInfo_OverlapCapacitance::_internal_mutable_bottom_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.bottom_layer_name_.Mutable( GetArena());
}
inline std::string* CapacitanceInfo_OverlapCapacitance::release_bottom_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.CapacitanceInfo.OverlapCapacitance.bottom_layer_name)
  return _impl_.bottom_layer_name_.Release();
}
inline void CapacitanceInfo_OverlapCapacitance::set_allocated_bottom_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bottom_layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bottom_layer_name_.IsDefault()) {
          _impl_.bottom_layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.CapacitanceInfo.OverlapCapacitance.bottom_layer_name)
}

// double capacitance = 3;
inline void CapacitanceInfo_OverlapCapacitance::clear_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacitance_ = 0;
}
inline double CapacitanceInfo_OverlapCapacitance::capacitance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.OverlapCapacitance.capacitance)
  return _internal_capacitance();
}
inline void CapacitanceInfo_OverlapCapacitance::set_capacitance(double value) {
  _internal_set_capacitance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.OverlapCapacitance.capacitance)
}
inline double CapacitanceInfo_OverlapCapacitance::_internal_capacitance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacitance_;
}
inline void CapacitanceInfo_OverlapCapacitance::_internal_set_capacitance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacitance_ = value;
}

// -------------------------------------------------------------------

// CapacitanceInfo_SidewallCapacitance

// string layer_name = 1;
inline void CapacitanceInfo_SidewallCapacitance::clear_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.ClearToEmpty();
}
inline const std::string& CapacitanceInfo_SidewallCapacitance::layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SidewallCapacitance.layer_name)
  return _internal_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacitanceInfo_SidewallCapacitance::set_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SidewallCapacitance.layer_name)
}
inline std::string* CapacitanceInfo_SidewallCapacitance::mutable_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.SidewallCapacitance.layer_name)
  return _s;
}
inline const std::string& CapacitanceInfo_SidewallCapacitance::_internal_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.layer_name_.Get();
}
inline void CapacitanceInfo_SidewallCapacitance::_internal_set_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.Set(value, GetArena());
}
inline std::string* CapacitanceInfo_SidewallCapacitance::_internal_mutable_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.layer_name_.Mutable( GetArena());
}
inline std::string* CapacitanceInfo_SidewallCapacitance::release_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.CapacitanceInfo.SidewallCapacitance.layer_name)
  return _impl_.layer_name_.Release();
}
inline void CapacitanceInfo_SidewallCapacitance::set_allocated_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.layer_name_.IsDefault()) {
          _impl_.layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.CapacitanceInfo.SidewallCapacitance.layer_name)
}

// double capacitance = 2;
inline void CapacitanceInfo_SidewallCapacitance::clear_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacitance_ = 0;
}
inline double CapacitanceInfo_SidewallCapacitance::capacitance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SidewallCapacitance.capacitance)
  return _internal_capacitance();
}
inline void CapacitanceInfo_SidewallCapacitance::set_capacitance(double value) {
  _internal_set_capacitance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SidewallCapacitance.capacitance)
}
inline double CapacitanceInfo_SidewallCapacitance::_internal_capacitance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacitance_;
}
inline void CapacitanceInfo_SidewallCapacitance::_internal_set_capacitance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacitance_ = value;
}

// double offset = 3;
inline void CapacitanceInfo_SidewallCapacitance::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = 0;
}
inline double CapacitanceInfo_SidewallCapacitance::offset() const {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SidewallCapacitance.offset)
  return _internal_offset();
}
inline void CapacitanceInfo_SidewallCapacitance::set_offset(double value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SidewallCapacitance.offset)
}
inline double CapacitanceInfo_SidewallCapacitance::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void CapacitanceInfo_SidewallCapacitance::_internal_set_offset(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// CapacitanceInfo_SideOverlapCapacitance

// string in_layer_name = 1;
inline void CapacitanceInfo_SideOverlapCapacitance::clear_in_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_layer_name_.ClearToEmpty();
}
inline const std::string& CapacitanceInfo_SideOverlapCapacitance::in_layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.in_layer_name)
  return _internal_in_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacitanceInfo_SideOverlapCapacitance::set_in_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.in_layer_name)
}
inline std::string* CapacitanceInfo_SideOverlapCapacitance::mutable_in_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_in_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.in_layer_name)
  return _s;
}
inline const std::string& CapacitanceInfo_SideOverlapCapacitance::_internal_in_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_layer_name_.Get();
}
inline void CapacitanceInfo_SideOverlapCapacitance::_internal_set_in_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_layer_name_.Set(value, GetArena());
}
inline std::string* CapacitanceInfo_SideOverlapCapacitance::_internal_mutable_in_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.in_layer_name_.Mutable( GetArena());
}
inline std::string* CapacitanceInfo_SideOverlapCapacitance::release_in_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.in_layer_name)
  return _impl_.in_layer_name_.Release();
}
inline void CapacitanceInfo_SideOverlapCapacitance::set_allocated_in_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.in_layer_name_.IsDefault()) {
          _impl_.in_layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.in_layer_name)
}

// string out_layer_name = 2;
inline void CapacitanceInfo_SideOverlapCapacitance::clear_out_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.out_layer_name_.ClearToEmpty();
}
inline const std::string& CapacitanceInfo_SideOverlapCapacitance::out_layer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.out_layer_name)
  return _internal_out_layer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CapacitanceInfo_SideOverlapCapacitance::set_out_layer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.out_layer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.out_layer_name)
}
inline std::string* CapacitanceInfo_SideOverlapCapacitance::mutable_out_layer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_out_layer_name();
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.out_layer_name)
  return _s;
}
inline const std::string& CapacitanceInfo_SideOverlapCapacitance::_internal_out_layer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.out_layer_name_.Get();
}
inline void CapacitanceInfo_SideOverlapCapacitance::_internal_set_out_layer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.out_layer_name_.Set(value, GetArena());
}
inline std::string* CapacitanceInfo_SideOverlapCapacitance::_internal_mutable_out_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.out_layer_name_.Mutable( GetArena());
}
inline std::string* CapacitanceInfo_SideOverlapCapacitance::release_out_layer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.out_layer_name)
  return _impl_.out_layer_name_.Release();
}
inline void CapacitanceInfo_SideOverlapCapacitance::set_allocated_out_layer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.out_layer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.out_layer_name_.IsDefault()) {
          _impl_.out_layer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.out_layer_name)
}

// double capacitance = 3;
inline void CapacitanceInfo_SideOverlapCapacitance::clear_capacitance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacitance_ = 0;
}
inline double CapacitanceInfo_SideOverlapCapacitance::capacitance() const {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.capacitance)
  return _internal_capacitance();
}
inline void CapacitanceInfo_SideOverlapCapacitance::set_capacitance(double value) {
  _internal_set_capacitance(value);
  // @@protoc_insertion_point(field_set:kpex.tech.CapacitanceInfo.SideOverlapCapacitance.capacitance)
}
inline double CapacitanceInfo_SideOverlapCapacitance::_internal_capacitance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacitance_;
}
inline void CapacitanceInfo_SideOverlapCapacitance::_internal_set_capacitance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacitance_ = value;
}

// -------------------------------------------------------------------

// CapacitanceInfo

// repeated .kpex.tech.CapacitanceInfo.SubstrateCapacitance substrates = 200;
inline int CapacitanceInfo::_internal_substrates_size() const {
  return _internal_substrates().size();
}
inline int CapacitanceInfo::substrates_size() const {
  return _internal_substrates_size();
}
inline void CapacitanceInfo::clear_substrates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.substrates_.Clear();
}
inline ::kpex::tech::CapacitanceInfo_SubstrateCapacitance* CapacitanceInfo::mutable_substrates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.substrates)
  return _internal_mutable_substrates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>* CapacitanceInfo::mutable_substrates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kpex.tech.CapacitanceInfo.substrates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_substrates();
}
inline const ::kpex::tech::CapacitanceInfo_SubstrateCapacitance& CapacitanceInfo::substrates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.substrates)
  return _internal_substrates().Get(index);
}
inline ::kpex::tech::CapacitanceInfo_SubstrateCapacitance* CapacitanceInfo::add_substrates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::kpex::tech::CapacitanceInfo_SubstrateCapacitance* _add = _internal_mutable_substrates()->Add();
  // @@protoc_insertion_point(field_add:kpex.tech.CapacitanceInfo.substrates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>& CapacitanceInfo::substrates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kpex.tech.CapacitanceInfo.substrates)
  return _internal_substrates();
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>&
CapacitanceInfo::_internal_substrates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.substrates_;
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SubstrateCapacitance>*
CapacitanceInfo::_internal_mutable_substrates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.substrates_;
}

// repeated .kpex.tech.CapacitanceInfo.OverlapCapacitance overlaps = 201;
inline int CapacitanceInfo::_internal_overlaps_size() const {
  return _internal_overlaps().size();
}
inline int CapacitanceInfo::overlaps_size() const {
  return _internal_overlaps_size();
}
inline void CapacitanceInfo::clear_overlaps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overlaps_.Clear();
}
inline ::kpex::tech::CapacitanceInfo_OverlapCapacitance* CapacitanceInfo::mutable_overlaps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.overlaps)
  return _internal_mutable_overlaps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>* CapacitanceInfo::mutable_overlaps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kpex.tech.CapacitanceInfo.overlaps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_overlaps();
}
inline const ::kpex::tech::CapacitanceInfo_OverlapCapacitance& CapacitanceInfo::overlaps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.overlaps)
  return _internal_overlaps().Get(index);
}
inline ::kpex::tech::CapacitanceInfo_OverlapCapacitance* CapacitanceInfo::add_overlaps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::kpex::tech::CapacitanceInfo_OverlapCapacitance* _add = _internal_mutable_overlaps()->Add();
  // @@protoc_insertion_point(field_add:kpex.tech.CapacitanceInfo.overlaps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>& CapacitanceInfo::overlaps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kpex.tech.CapacitanceInfo.overlaps)
  return _internal_overlaps();
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>&
CapacitanceInfo::_internal_overlaps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overlaps_;
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_OverlapCapacitance>*
CapacitanceInfo::_internal_mutable_overlaps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.overlaps_;
}

// repeated .kpex.tech.CapacitanceInfo.SidewallCapacitance sidewalls = 202;
inline int CapacitanceInfo::_internal_sidewalls_size() const {
  return _internal_sidewalls().size();
}
inline int CapacitanceInfo::sidewalls_size() const {
  return _internal_sidewalls_size();
}
inline void CapacitanceInfo::clear_sidewalls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sidewalls_.Clear();
}
inline ::kpex::tech::CapacitanceInfo_SidewallCapacitance* CapacitanceInfo::mutable_sidewalls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.sidewalls)
  return _internal_mutable_sidewalls()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>* CapacitanceInfo::mutable_sidewalls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kpex.tech.CapacitanceInfo.sidewalls)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sidewalls();
}
inline const ::kpex::tech::CapacitanceInfo_SidewallCapacitance& CapacitanceInfo::sidewalls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.sidewalls)
  return _internal_sidewalls().Get(index);
}
inline ::kpex::tech::CapacitanceInfo_SidewallCapacitance* CapacitanceInfo::add_sidewalls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::kpex::tech::CapacitanceInfo_SidewallCapacitance* _add = _internal_mutable_sidewalls()->Add();
  // @@protoc_insertion_point(field_add:kpex.tech.CapacitanceInfo.sidewalls)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>& CapacitanceInfo::sidewalls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kpex.tech.CapacitanceInfo.sidewalls)
  return _internal_sidewalls();
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>&
CapacitanceInfo::_internal_sidewalls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sidewalls_;
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SidewallCapacitance>*
CapacitanceInfo::_internal_mutable_sidewalls() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sidewalls_;
}

// repeated .kpex.tech.CapacitanceInfo.SideOverlapCapacitance sideoverlaps = 203;
inline int CapacitanceInfo::_internal_sideoverlaps_size() const {
  return _internal_sideoverlaps().size();
}
inline int CapacitanceInfo::sideoverlaps_size() const {
  return _internal_sideoverlaps_size();
}
inline void CapacitanceInfo::clear_sideoverlaps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sideoverlaps_.Clear();
}
inline ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance* CapacitanceInfo::mutable_sideoverlaps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:kpex.tech.CapacitanceInfo.sideoverlaps)
  return _internal_mutable_sideoverlaps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>* CapacitanceInfo::mutable_sideoverlaps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:kpex.tech.CapacitanceInfo.sideoverlaps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sideoverlaps();
}
inline const ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance& CapacitanceInfo::sideoverlaps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kpex.tech.CapacitanceInfo.sideoverlaps)
  return _internal_sideoverlaps().Get(index);
}
inline ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance* CapacitanceInfo::add_sideoverlaps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::kpex::tech::CapacitanceInfo_SideOverlapCapacitance* _add = _internal_mutable_sideoverlaps()->Add();
  // @@protoc_insertion_point(field_add:kpex.tech.CapacitanceInfo.sideoverlaps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>& CapacitanceInfo::sideoverlaps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:kpex.tech.CapacitanceInfo.sideoverlaps)
  return _internal_sideoverlaps();
}
inline const ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>&
CapacitanceInfo::_internal_sideoverlaps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sideoverlaps_;
}
inline ::google::protobuf::RepeatedPtrField<::kpex::tech::CapacitanceInfo_SideOverlapCapacitance>*
CapacitanceInfo::_internal_mutable_sideoverlaps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sideoverlaps_;
}

// -------------------------------------------------------------------

// StyleVariant

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace tech
}  // namespace kpex


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_extract_2eproto_2epb_2eh
